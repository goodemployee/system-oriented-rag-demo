# System-Oriented AI Architecture Demo (RAG as Example)

> 本專案是一個以 RAG 作為載體的系統化工程展示，
> 重點不在模型效果，而在於如何避免生成式 AI 系統在實務中失控。

## 專案簡介

本專案是一個以 **RAG（Retrieval-Augmented Generation）** 為題材的系統化工程展示，重點**不在於模型效果或應用完成度**，而在於：

* 如何將 RAG 拆解為可理解、可替換、可維護的系統結構
* 如何在模型、資料與流程之間維持清楚的依賴方向
* 如何避免「功能堆疊型」RAG 專案常見的複雜度失控問題

本專案刻意設定為 **展示用、非生產環境**，目的在於呈現：

> **當架構清楚時，系統開發會自然變得順暢，RAG 只是其中一種被良好承載的能力。**

---

## 系統整體架構概覽

系統採用明確的分層設計，由外而內大致可分為：

```
HTTP / Web API
└─ UseCases（流程協調）
   └─ Application Services（服務層）
      └─ Core Systems（核心能力）
         └─ Infrastructure（基礎設施）
```

另有一組與核心系統**同層但非必要**的輔助模組：

```
Capabilities（可有可無，但能降低使用門檻）
```

以及一個刻意被隔離的資料區：

```
Data（非邏輯、非規則）
```

整體設計遵守以下原則：

* **依賴方向單向且具因果意義**
* 上層只關心「做什麼」，不關心「怎麼做」
* 核心邏輯不反向依賴應用或介面層

---

## 模組分層與責任說明

### HTTP / Routes

**責任**

* 接收請求、回傳回應
* 僅處理輸入輸出格式與路由

**刻意不做**

* 不處理業務流程
* 不組合系統邏輯
* 不直接操作核心系統

> Web API 保持「薄」，是為了避免架構被請求形式綁死。

---

### UseCases（Application Layer）

**責任**

* 定義「一個請求代表什麼行為」
* 協調多個 service 的呼叫順序
* 封裝流程，而非實作邏輯

**刻意不做**

* 不實作 RAG 細節
* 不直接依賴模型或儲存實作

> UseCase 的存在，是為了讓流程可讀、可測、可替換。

---

### Application Services

**責任**

* 將核心系統組合成可被使用的「服務」
* 對外提供穩定介面，對內管理複雜度

**刻意不做**

* 不處理請求格式
* 不隱含業務流程假設

> Service 層的角色，是「使用系統」，而不是「成為系統」。

---

### Core（核心系統）

**包含**

* Embedding / Chunking
* Graph 建構與查詢
* LLM 抽象介面

**責任**

* 純粹表達「系統能力」
* 不知道自己被誰使用
* 不假設應用場景

**刻意不做**

* 不關心 Web、API 或 UseCase
* 不處理部署與環境問題

> Core 的目標是：即使被單獨取出，仍然有清楚意義。

---

### Capabilities（輔助能力）

**定位**

* 與 Core 同層
* 即使移除，也不會動搖專案的核心概念

**用途**

* 提供便利的封裝
* 降低使用門檻
* 簡化常見操作

> Capabilities 是「讓事情變簡單」，而不是「讓系統成立」。

---

### Infrastructure（基礎設施層）

**責任**

* 提供模型、儲存、外部資源的實際實作
* 集中處理技術細節與替換點

**特性**

* 模型採 lazy loading
* 提供者與使用者解耦

> Infrastructure 是唯一允許「現實世界複雜度」存在的地方。

---

### Data（資料區）

**用途**

* 放置非邏輯、非規則的資料
* 暫存、快取、生成結果

**刻意設計**

* 不承載路徑規則
* 不成為依賴來源

> Data 存在，但不參與決策。

---

## 重要設計取捨

* **多層拆分而非快速直寫**

  * 初期成本較高，但能有效避免後期重構地獄

* **模型提供者抽象化**

  * 模型不是系統的中心，而是可替換的資源

* **Lazy Loading**

  * 減少啟動負擔
  * 將成本延後到真正需要時

* **限制資訊逆流**

  * 設計依賴方向與因果方向一致
  * 避免「下層知道太多上層意圖」

* **測試經驗的反思**

  * 專案早期過度追求速度，導致可測性不足
  * 後續刻意補上核心行為測試，作為架構校正工具

這些議題在實務中極其重要，但在此專案中若一併處理，
將會模糊本示範真正想傳達的工程焦點。

---

## 刻意省略與未涵蓋範圍

本專案**明確知道但刻意不處理**以下議題：

* 深度 Prompt Engineering
* 高品質模型選型與調校
* Embedding 前處理與最佳化流程
* 生產級穩定性與效能調校
* 一鍵部署、自動化、容器化
* 完整應用包裝或產品化
* 更激進的實驗性架構（例如 ECS 化）

原因並非不重要，而是這些議題**會掩蓋本專案真正想展示的重點：架構與責任劃分**。

---

## 建議閱讀方式

本專案並非設計為從 README 一路執行到結果。
若你是工程背景讀者，建議依序閱讀：

1. `core/`：理解系統真正的能力邊界
2. `application/usecases/`：理解流程如何被描述
3. `application/services/`：理解系統如何被使用
4. `infrastructure/`：理解替換點如何被保留

不需要從 Web API 開始，因為那不是這個專案的核心。

---

## 總結

這不是一個「完成的 RAG 產品」，
而是一個關於 **如何讓 RAG 不失控** 的工程示範。

如果你關心的是：

* 架構是否能承載未來變化
* 系統是否能被理解、維護與擴充
* 工程設計是否有節制與自覺

那這個專案正是為了展示這些而存在。

---

## 感言

AI 的發展使內容產生逐步自動化，
而系統架構的角色，則在於抑制與管理隨之而來的複雜度。
從長期來看，穩定的工程實踐必須同時兼顧兩者。
